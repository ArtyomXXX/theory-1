# theory-1


# Написать что выводит данный код
______________________________________________________________________________

<nobr>
    const arr = [10, 12, 15, 21];

    for(var i = 0; i < arr.length; i++){
        setTimeout(function() {
            console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`)
        }, 3000)
    }
</nobr>

# Ответ!
______________________________________________________________________________

Данный код выводит следующее:   Bad: undefined
                                Bad: undefined
                                Bad: undefined
                                Bad: undefined

Это происходит из-за того, что используется `var` для объявления переменной `i` в цикле.
В результате переменная `i` имеет глобальную область видимости и будет иметь значение `4` после завершения цикла.
Таким образом, к моменту выполнения функции `setTimeout`, значение `i` будет уже равно `4`, и попытка доступа к элементу
массива `arr[4]` вызовет ошибку и вернёт значение `undefined`.

Чтобы исправить это поведение, нужно использовать `let` вместо `var` для объявления переменной `i`.
Это создаст блочную область видимости для переменной `i`, и каждый вызов функции `setTimeout`
будет иметь своё собственное значение `i` в соответствии с текущей итерацией.


# Варианты модификации кода
______________________________________________________________________________

Вариант 1:

Можно просто пробежаться по элементам массива и условным оператором if определить есть ли числа больше 13.

<nobr>
    const arr = [10, 12, 15, 21];

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > 13) {
            console.log(`Good: ${arr[i]}`);
        } else {
            console.log(`Bad: ${arr[i]}`);
        }
    }
</nobr>


______________________________________________________________________________

Вариант 2:

Использовать метод map(),

<nobr>
    const arr = [10, 12, 15, 21];

    arr.map((arr) => {
        console.log(arr > 13 ? `Good: ${arr}` : `Bad: ${arr}`);
    })
</nobr>