# theory-1


# Написать что выводит данный код
______________________________________________________________________________

const arr = [10, 12, 15, 21];

for(var i = 0; i < arr.length; i++){
    setTimeout(function() {
        console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`)
    }, 3000)
}

# Ответ!
______________________________________________________________________________

Данный код выводит следующее:   Bad: undefined
                                Bad: undefined
                                Bad: undefined
                                Bad: undefined

Это происходит из-за того, что используется `var` для объявления переменной `i` в цикле.
В результате переменная `i` имеет глобальную область видимости и будет иметь значение `4` после завершения цикла.
Таким образом, к моменту выполнения функции `setTimeout`, значение `i` будет уже равно `4`, и попытка доступа к элементу
массива `arr[4]` вызовет ошибку и вернёт значение `undefined`.

Чтобы исправить это поведение, нужно использовать `let` вместо `var` для объявления переменной `i`.
Это создаст блочную область видимости для переменной `i`, и каждый вызов функции `setTimeout`
будет иметь своё собственное значение `i` в соответствии с текущей итерацией.


# Варианты модификации кода
______________________________________________________________________________

Вариант 1:

Можно просто пробежаться по элементам массива и условным оператором if определить есть ли числа больше 13.

const arr = [10, 12, 15, 21];

for (let i = 0; i < arr.length; i++) {
    if (arr[i] > 13) {
        console.log(`Good: ${arr[i]}`);
    } else {
        console.log(`Bad: ${arr[i]}`);
    }
}


______________________________________________________________________________

Вариант 2:

Использовать метод map(),

const arr = [10, 12, 15, 21];

arr.map((arr) => {
    console.log(arr > 13 ? `Good: ${arr}` : `Bad: ${arr}`);
})